"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6808],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var o=t(96540);const r={},a=o.createContext(r);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:n},e.children)}},31578:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=t(74848),r=t(28453);const a={title:"Why Do Call Arrays Need Functions?"},i=void 0,s={id:"Why-Do-Call-Arrays-Need-Functions",title:"Why Do Call Arrays Need Functions?",description:'"Hang on a minute," you\'re now thinking. "Why do I need to override a function, call it to get the table, and then insert my new call? Why don\'t you just have a global table? Then I could insert my new call and skip that override business."',source:"@site/docs/Why-Do-Call-Arrays-Need-Functions.md",sourceDirName:".",slug:"/Why-Do-Call-Arrays-Need-Functions",permalink:"/docs/Why-Do-Call-Arrays-Need-Functions",draft:!1,unlisted:!1,editUrl:"https://github.com/premake/premake-core/edit/master/website/docs/Why-Do-Call-Arrays-Need-Functions.md",tags:[],version:"current",lastUpdatedBy:"starkos",lastUpdatedAt:1615992656e3,frontMatter:{title:"Why Do Call Arrays Need Functions?"}},c={},l=[];function d(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:'"Hang on a minute,"'})," you're now thinking. ",(0,o.jsx)(n.em,{children:'"Why do I need to override a function, call it to get the table, and then insert my new call? Why don\'t you just have a global table? Then I could insert my new call and skip that override business."'})]}),"\n",(0,o.jsx)(n.p,{children:"In other words, why couldn't the list of functions look like this instead?"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'m.elements.project = {\n\tm.xmlDeclaration,\n\tm.project,\n\tm.projectConfigurations,\n\t-- and so on...\n}\n\n-- then I could do this:\n\ntable.insertafter(m.elements.project, m.xmlDeclaration, myNewFunction)\n\n-- instead of this!\n\npremake.override(m.elements, "project", function(base, prj)\n\tlocal calls = base(prj)\n\ttable.insertafter(calls, m.xmlDeclaration, myNewFunction)\n\treturn calls\nend)\n'})}),"\n",(0,o.jsx)(n.p,{children:"The answer: that would break the ability to override the functions in the array. Let me explain..."}),"\n",(0,o.jsx)(n.p,{children:"The functions being included in the array are resolved at the time the code is evaluated. For a global table that means at the time the script is first loaded and executed."}),"\n",(0,o.jsxs)(n.p,{children:["When the code is executed, ",(0,o.jsx)(n.code,{children:"m.project"})," (perhaps better thought of here as ",(0,o.jsx)(n.code,{children:'m["project"]'}),") is evaluated and ",(0,o.jsx)(n.em,{children:"the function it represents"})," is stored into the array. Kind of like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"m.elements.project = {\n\tfunction: 0x10017b280\n\tfunction: 0x100124dd0\n\tfunction: 0x10017b2c0\n\t-- and so on...\n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["That's all well and good: ",(0,o.jsx)(n.code,{children:"m.project"})," evaluates to ",(0,o.jsx)(n.code,{children:"function: 0x100124dd0"})," and that's what is in the array."]}),"\n",(0,o.jsxs)(n.p,{children:["Now what happens if want to override ",(0,o.jsx)(n.code,{children:"m.project"}),"?"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'premake.override(m, "project", function(base, prj)\n\tprint("All your base are belong to us")\n\tbase(prj)\nend)\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"premake.override()"})," takes your new replacement function and assigns it to ",(0,o.jsx)(n.code,{children:"m.project"})," (or ",(0,o.jsx)(n.code,{children:'m["project"]'})," if that's easier to visualize). Which means the symbol ",(0,o.jsx)(n.code,{children:"m.project"})," now evaluates to a different function, say ",(0,o.jsx)(n.code,{children:"function: 0x100300360"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you call ",(0,o.jsx)(n.code,{children:"m.project(prj)"})," directly, your replacement function will be executed as expected. However, since the ",(0,o.jsx)(n.code,{children:"m.elements.project"})," table has already been evaluated, it still points to the original ",(0,o.jsx)(n.code,{children:"function: 0x100124dd0"}),". Which means that when the Visual Studio project is generated and that call array is processed, your override will be ignored."]}),"\n",(0,o.jsxs)(n.p,{children:["So getting to the point: by putting the call array table inside a function, we defer evaluation ",(0,o.jsx)(n.em,{children:"until the function is actually called"}),". Since all of the user scripts are called before the Visual Studio project is generated, your override will already be in place, ",(0,o.jsx)(n.code,{children:"m.project"})," will evaluate to your replacement function (",(0,o.jsx)(n.code,{children:"function: 0x100300360"})," instead of ",(0,o.jsx)(n.code,{children:"function: 0x100124dd0"}),"), and the correct code will be run."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);