"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[908],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},34511:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={title:"Overrides & Call Arrays"},i=void 0,l={unversionedId:"Overrides-and-Call-Arrays",id:"Overrides-and-Call-Arrays",isDocsHomePage:!1,title:"Overrides & Call Arrays",description:"Premake's extensibility is built around two coding conventions: overrides, a formalized way of replacing one function with another, and call arrays, a way of sequencing a series of steps at runtime.",source:"@site/docs/Overrides-and-Call-Arrays.md",sourceDirName:".",slug:"/Overrides-and-Call-Arrays",permalink:"/docs/Overrides-and-Call-Arrays",editUrl:"https://github.com/premake/premake-core/edit/master/website/docs/Overrides-and-Call-Arrays.md",tags:[],version:"current",lastUpdatedBy:"KyrietS",lastUpdatedAt:1631130138,formattedLastUpdatedAt:"9/8/2021",frontMatter:{title:"Overrides & Call Arrays"},sidebar:"docs",previous:{title:"Coding Conventions",permalink:"/docs/Coding-Conventions"},next:{title:"Developing Modules",permalink:"/docs/Developing-Modules"}},s=[{value:"Your First Customization",id:"your-first-customization",children:[],level:2},{value:"Use the Source!",id:"use-the-source",children:[],level:2},{value:"Introducing Overrides",id:"introducing-overrides",children:[],level:2},{value:"Introducing Call Arrays",id:"introducing-call-arrays",children:[],level:2}],p={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Premake's extensibility is built around two coding conventions: ",(0,a.kt)("em",{parentName:"p"},"overrides"),", a formalized way of replacing one function with another, and ",(0,a.kt)("em",{parentName:"p"},"call arrays"),", a way of sequencing a series of steps at runtime."),(0,a.kt)("h2",{id:"your-first-customization"},"Your First Customization"),(0,a.kt)("p",null,"Let's jump right in with a simple example. Let's say that we're planning to keep our Premake-generated Visual Studio projects around for a while and, for historical reference, we'd like to know which version of Premake was used to generate them. To do so, we would like to add an XML comment to the top of the generated project files, like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="utf-8"?>\n\x3c!-- Generated by Premake 5.0.0-alpha3 --\x3e\n<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">\n  <ItemGroup Label="ProjectConfigurations">\n  \x3c!-- ... and so on... --\x3e\n')),(0,a.kt)("p",null,"We don't want to modify Premake's own source code, because then our changes would be overwritten by each new update, and we'd be stuck maintaining our own fork of the code. It would also mean that everyone who generated our projects would need to have the customized version of Premake, otherwise we'd end up with generated projects that did not contain our version commment."),(0,a.kt)("p",null,"Instead, we'd really like to implement this customization right in our project scripts. That way we can share the scripts with any developer, and they can then generate a new project that has the version comment in it."),(0,a.kt)("h2",{id:"use-the-source"},"Use the Source!"),(0,a.kt)("p",null,"Before we can make this change, we first need to know what function in the Premake source code is emitting this particular markup. As described in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/Code-Overview"},"Code Overview"),", the Visual Studio exporter is currently located in the ",(0,a.kt)("inlineCode",{parentName:"p"},"src/actions/vstudio")," folder in the Premake source tree (go ahead and find it, we'll wait!)."),(0,a.kt)("p",null,"We're looking for the code which generates the ",(0,a.kt)("inlineCode",{parentName:"p"},".vcxproj")," files, and browsing the file names brings us to ",(0,a.kt)("inlineCode",{parentName:"p"},"vs2010_vcxproj.lua"),". Opening this file, we can then search for the ",(0,a.kt)("inlineCode",{parentName:"p"},'"<Project"')," string, which we find in the ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'    function m.project(prj)\n        local action = premake.action.current()\n        p.push(\'<Project DefaultTargets="Build" ToolsVersion="%s" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">\',\n            action.vstudio.toolsVersion)\n    end\n')),(0,a.kt)("p",null,"(Or, if you are using a tool which supports it, it can be quicker to just run a full text search across the Premake sources for the markup you are looking to override.)"),(0,a.kt)("p",null,"For the moment we don't really need to worry too much about how this code works because we aren't actually going to change it at all. Instead, we will ",(0,a.kt)("em",{parentName:"p"},"override")," it with a new function that outputs our version comment, and then calls the original function to output the Project element, unmodified."),(0,a.kt)("p",null,"Before we can do that, we need one more bit of information: what is ",(0,a.kt)("inlineCode",{parentName:"p"},"m"),"? ",(0,a.kt)("a",{parentName:"p",href:"/docs/Coding-Conventions"},"By convention"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"m")," is a shortcut for the module's namespace (really just a Lua table) which we declare at the top of the file. Looking at the top of ",(0,a.kt)("inlineCode",{parentName:"p"},"vs2010_vcxproj.lua")," we find:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local p = premake\nlocal m = p.vstudio.vc2010\n")),(0,a.kt)("p",null,"Expanding that out, we can deduce that the fully-qualified name of the function we want to override is ",(0,a.kt)("inlineCode",{parentName:"p"},"premake.vstudio.vc2010.project()"),"."),(0,a.kt)("h2",{id:"introducing-overrides"},"Introducing Overrides"),(0,a.kt)("p",null,"Now that we've identified the function that emits the markup we wish to change, we can override it using Premake's aptly named ",(0,a.kt)("inlineCode",{parentName:"p"},"override()")," function."),(0,a.kt)("p",null,"Note that actions don't get pulled in until they are actually used so you will need to require it in order to access it"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"require('vstudio')\n")),(0,a.kt)("p",null,"Then (and only then) you can go ahead and call the override function !"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"premake.override(premake.vstudio.vc2010, \"project\", function(base, prj)\n    premake.w('\x3c!-- Generated by Premake ' .. _PREMAKE_VERSION .. ' --\x3e')\n    base(prj)\nend)\n")),(0,a.kt)("p",null,"This snippet replaces the original implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()")," with my new (anonymous) function. From this point on, when someone calls ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()"),", Premake will call my new function, passing it the original implementation as the first argument (",(0,a.kt)("inlineCode",{parentName:"p"},"base"),"). If the function requires any other arguments (in this case, it receives the project being exported as ",(0,a.kt)("inlineCode",{parentName:"p"},"prj"),") they appear after."),(0,a.kt)("p",null,"In our replacement function, we emit our comment header using ",(0,a.kt)("inlineCode",{parentName:"p"},"premake.w()"),', which is short for "premake write", and ',(0,a.kt)("a",{parentName:"p",href:"/docs/_PREMAKE_VERSION"},"_PREMAKE_VERSION"),", which is a global variable holding the version of the currently running Premake executable."),(0,a.kt)("p",null,"After emitting the comment we call ",(0,a.kt)("inlineCode",{parentName:"p"},"base(prj)"),", the original implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()"),", to do the rest of the work for us. Easy!"),(0,a.kt)("p",null,"To enable our override, place that code anywhere in your project or system scripts. Perhaps something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'workspace "MyWorkspace"\n   configurations { "Debug", "Release" }\n\nproject "MyProject"\n   kind "ConsoleApp"\n   -- ... the rest of the project settings...\n\n-- Write the current Premake version into our generated files, for reference\npremake.override(premake.vstudio.vc2010, "project", function(base, prj)\n    premake.w(\'\x3c!-- Generated by Premake \' .. _PREMAKE_VERSION .. \' --\x3e\')\n    base(prj)\nend)\n')),(0,a.kt)("p",null,"The next time you generate a Visual Studio project from your scripts, the comment header will be placed before the Project element."),(0,a.kt)("h2",{id:"introducing-call-arrays"},"Introducing Call Arrays"),(0,a.kt)("p",null,"Overrides are a great way to intercept an existing call to modify its arguments or return value or even replace it entirely. There is another, more self-contained way that we could have implemented our customization by leveraging ",(0,a.kt)("a",{parentName:"p",href:"/docs/Coding-Conventions"},"Premake's ",(0,a.kt)("em",{parentName:"a"},"call array")," convention"),"."),(0,a.kt)("p",null,"If you look at the top of ",(0,a.kt)("inlineCode",{parentName:"p"},"vs2010_vcxproj.lua"),", you will see that ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()")," is called via an array of function references:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"m.elements.project = function(prj)\n    return {\n        m.xmlDeclaration,\n        m.project,\n        m.projectConfigurations,\n        m.globals,\n        m.importDefaultProps,\n        m.configurationPropertiesGroup,\n        m.importExtensionSettings,\n        m.propertySheetGroup,\n        m.userMacros,\n        m.outputPropertiesGroup,\n        m.itemDefinitionGroups,\n        m.assemblyReferences,\n        m.files,\n        m.projectReferences,\n        m.importExtensionTargets,\n    }\nend\n\nfunction m.generate(prj)\n    io.utf8()\n    p.callArray(m.elements.project, prj)\n    p.out('</Project>')\nend\n")),(0,a.kt)("p",null,"Premake calls ",(0,a.kt)("inlineCode",{parentName:"p"},"m.generate()")," to export the project\u2014we'll talk about how that happens later. ",(0,a.kt)("inlineCode",{parentName:"p"},"m.generate()")," calls ",(0,a.kt)("inlineCode",{parentName:"p"},"p.callArray()")," (remember ",(0,a.kt)("a",{parentName:"p",href:"/docs/Coding-Conventions"},(0,a.kt)("inlineCode",{parentName:"a"},"p")," is an alias for ",(0,a.kt)("inlineCode",{parentName:"a"},"premake")),"), which calls all of the functions in the list returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"m.elements.project()"),", passing the provided arguments (in this case ",(0,a.kt)("inlineCode",{parentName:"p"},"prj"),") to each of them. This indirection allows project script authors like yourself an opportunity to modify that list of calls by adding, removing, or reordering the list."),(0,a.kt)("p",null,"Let's implement our version comment as an addition to this particular call array. To do so, we will override the ",(0,a.kt)("inlineCode",{parentName:"p"},"m.elements.project()")," function (remember from the earlier example that ",(0,a.kt)("inlineCode",{parentName:"p"},"m")," is short for ",(0,a.kt)("inlineCode",{parentName:"p"},"premake.vstudio.vc2010"),"). We'll call the original implementation to get the array of calls, and then add our own before returning it to ",(0,a.kt)("inlineCode",{parentName:"p"},"m.generate()"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local function premakeVersionComment(prj)\n    premake.w('\x3c!-- Generated by Premake ' .. _PREMAKE_VERSION .. ' --\x3e')\nend\n\npremake.override(premake.vstudio.vc2010.elements, \"project\", function(base, prj)\n    local calls = base(prj)\n    table.insertafter(calls, m.xmlDeclaration, premakeVersionComment)\n    return calls\nend)\n")),(0,a.kt)("p",null,"If you add that snippet to your project or system script, your new function will get called between ",(0,a.kt)("inlineCode",{parentName:"p"},"m.xmlDeclaration()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project()")," and place our comment right where we'd like it."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"(Wondering ",(0,a.kt)("a",{parentName:"em",href:"/docs/Why-Do-Call-Arrays-Need-Functions"},"why the call array is in a function and not just a global table"),"? Hint: because otherwise overrides wouldn't work.)")))}c.isMDXComponent=!0}}]);