"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8041],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,h=u["".concat(c,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},54843:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const o={title:"Why Do Call Arrays Need Functions?"},i=void 0,l={unversionedId:"Why-Do-Call-Arrays-Need-Functions",id:"Why-Do-Call-Arrays-Need-Functions",isDocsHomePage:!1,title:"Why Do Call Arrays Need Functions?",description:'"Hang on a minute," you\'re now thinking. "Why do I need to override a function, call it to get the table, and then insert my new call? Why don\'t you just have a global table? Then I could insert my new call and skip that override business."',source:"@site/docs/Why-Do-Call-Arrays-Need-Functions.md",sourceDirName:".",slug:"/Why-Do-Call-Arrays-Need-Functions",permalink:"/docs/Why-Do-Call-Arrays-Need-Functions",editUrl:"https://github.com/premake/premake-core/edit/master/website/docs/Why-Do-Call-Arrays-Need-Functions.md",tags:[],version:"current",lastUpdatedBy:"starkos",lastUpdatedAt:1615992656,formattedLastUpdatedAt:"3/17/2021",frontMatter:{title:"Why Do Call Arrays Need Functions?"}},c=[],s={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},'"Hang on a minute,"')," you're now thinking. ",(0,a.kt)("em",{parentName:"p"},'"Why do I need to override a function, call it to get the table, and then insert my new call? Why don\'t you just have a global table? Then I could insert my new call and skip that override business."')),(0,a.kt)("p",null,"In other words, why couldn't the list of functions look like this instead?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'m.elements.project = {\n    m.xmlDeclaration,\n    m.project,\n    m.projectConfigurations,\n    -- and so on...\n}\n\n-- then I could do this:\n\ntable.insertafter(m.elements.project, m.xmlDeclaration, myNewFunction)\n\n-- instead of this!\n\npremake.override(m.elements, "project", function(base, prj)\n    local calls = base(prj)\n    table.insertafter(calls, m.xmlDeclaration, myNewFunction)\n    return calls\nend)\n')),(0,a.kt)("p",null,"The answer: that would break the ability to override the functions in the array. Let me explain..."),(0,a.kt)("p",null,"The functions being included in the array are resolved at the time the code is evaluated. For a global table that means at the time the script is first loaded and executed."),(0,a.kt)("p",null,"When the code is executed, ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project")," (perhaps better thought of here as ",(0,a.kt)("inlineCode",{parentName:"p"},'m["project"]'),") is evaluated and ",(0,a.kt)("em",{parentName:"p"},"the function it represents")," is stored into the array. Kind of like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"m.elements.project = {\n    function: 0x10017b280\n    function: 0x100124dd0\n    function: 0x10017b2c0\n    -- and so on...\n\n}\n")),(0,a.kt)("p",null,"That's all well and good: ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project")," evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"function: 0x100124dd0")," and that's what is in the array."),(0,a.kt)("p",null,"Now what happens if want to override ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project"),"?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'premake.override(m, "project", function(base, prj)\n    print("All your base are belong to us")\n    base(prj)\nend)\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"premake.override()")," takes your new replacement function and assigns it to ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},'m["project"]')," if that's easier to visualize). Which means the symbol ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project")," now evaluates to a different function, say ",(0,a.kt)("inlineCode",{parentName:"p"},"function: 0x100300360"),"."),(0,a.kt)("p",null,"If you call ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project(prj)")," directly, your replacement function will be executed as expected. However, since the ",(0,a.kt)("inlineCode",{parentName:"p"},"m.elements.project")," table has already been evaluated, it still points to the original ",(0,a.kt)("inlineCode",{parentName:"p"},"function: 0x100124dd0"),". Which means that when the Visual Studio project is generated and that call array is processed, your override will be ignored."),(0,a.kt)("p",null,"So getting to the point: by putting the call array table inside a function, we defer evaluation ",(0,a.kt)("em",{parentName:"p"},"until the function is actually called"),". Since all of the user scripts are called before the Visual Studio project is generated, your override will already be in place, ",(0,a.kt)("inlineCode",{parentName:"p"},"m.project")," will evaluate to your replacement function (",(0,a.kt)("inlineCode",{parentName:"p"},"function: 0x100300360")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"function: 0x100124dd0"),"), and the correct code will be run."))}u.isMDXComponent=!0}}]);