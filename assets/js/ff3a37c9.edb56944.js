"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6721],{18232:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var t=i(74848),s=i(28453);const l={},r=void 0,a={id:"links",title:"links",description:"Specifies a list of libraries and projects to link against.",source:"@site/docs/links.md",sourceDirName:".",slug:"/links",permalink:"/docs/links",draft:!1,unlisted:!1,editUrl:"https://github.com/premake/premake-core/edit/master/website/docs/links.md",tags:[],version:"current",lastUpdatedBy:"Nicholaus Clark",lastUpdatedAt:1648604801e3,frontMatter:{},sidebar:"docs",previous:{title:"linkoptions",permalink:"/docs/linkoptions"},next:{title:"linktimeoptimization",permalink:"/docs/linktimeoptimization"}},o={},c=[{value:"Parameters",id:"parameters",level:3},{value:"Applies To",id:"applies-to",level:3},{value:"Availability",id:"availability",level:3},{value:"Examples",id:"examples",level:3}];function d(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Specifies a list of libraries and projects to link against."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'links { "references" }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"references"})," is a list of library and project names."]}),"\n",(0,t.jsx)(n.p,{children:"When linking against another project in the same workspace, specify the project name here, rather than the library name. Premake will figure out the correct library to link against for the current configuration, and will also create a dependency between the projects to ensure a proper build order."}),"\n",(0,t.jsx)(n.p,{children:"When linking against system libraries, do not include any prefix or file extension. Premake will use the appropriate naming conventions for the current platform. With two exceptions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'Managed C++ projects can link against managed assemblies by explicitly specifying the ".dll" file extension. Unmanaged libraries should continue to be specified without any decoration.'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'Objective C frameworks can be linked by explicitly including the ".framework" file extension.'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For Visual Studio, this will add the specified project into References.  In contrast, 'dependson' generates a build order dependency in the solution between two projects."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"applies-to",children:"Applies To"}),"\n",(0,t.jsx)(n.p,{children:"Project configurations."}),"\n",(0,t.jsx)(n.h3,{id:"availability",children:"Availability"}),"\n",(0,t.jsx)(n.p,{children:"Premake 4.0 or later."}),"\n",(0,t.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.p,{children:"Link against some system libraries."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'filter { "system:windows" }\n   links { "user32", "gdi32" }\n\nfilter { "system:linux" }\n   links { "m", "png" }\n\nfilter { "system:macosx" }\n   -- OS X frameworks need the extension to be handled properly\n   links { "Cocoa.framework", "png" }\n'})}),"\n",(0,t.jsx)(n.p,{children:"In a workspace with two projects, link the library into the executable. Note that the project name is used to specify the link; Premake will automatically figure out the correct library file name and directory and create a project dependency."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'workspace "MyWorkspace"\n   configurations { "Debug", "Release" }\n   language "C++"\n\n   project "MyExecutable"\n      kind "ConsoleApp"\n      files "**.cpp"\n      links { "MyLibrary" }\n\n   project "MyLibrary"\n      kind "SharedLib"\n      files "**.cpp"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You may specify the linking mechanism explicitly for each library.  To set the link type of a library explicitly, add a ",(0,t.jsx)(n.code,{children:":static"})," or ",(0,t.jsx)(n.code,{children:":shared"})," suffix to the library.  Note that this functionality is only available for the ",(0,t.jsx)(n.code,{children:"gcc"})," and ",(0,t.jsx)(n.code,{children:"clang"})," toolsets."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'workspace "MyWorkspace"\n   configurations { "Debug", "Release" }\n   language "C++"\n\n   project "MyExecutable"\n      kind "ConsoleApp"\n      files "**.cpp"\n      links { "LibraryA:static", "LibraryB:shared" }\n'})}),"\n",(0,t.jsx)(n.p,{children:"You may also create links between non-library projects. In this case, Premake will generate a build dependency (the linked project will build first), but not an actual link. In this example, MyProject uses a build dependency to ensure that MyTool gets built first. It then uses MyTool as part of its build process."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'workspace "MyWorkspace"\n   configurations { "Debug", "Release" }\n   language "C++"\n\n   project "MyProject"\n      kind "ConsoleApp"\n      files "**.cpp"\n      links { "MyTool" }\n      prebuildcommands { "MyTool --dosomething" }\n\n   project "MyTool"\n      kind "ConsoleApp"\n      files "**.cpp"\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const s={},l=t.createContext(s);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);